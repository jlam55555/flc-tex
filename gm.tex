\section{G-Machine (GM) implementation}
\label{sec:gm}

The G-Machine is an abstract machine with a very similar idea to the TI machine with graph reduction and unwinding. The difference is that the graph creation, which is a complicated process performed by the instantiation step of the TI machine, is compiled into a series of opcodes on a stack-based machine. The unwinding step remains largely the same. The state of the machine is largely the same, with a stack, dump, and heap. Notably, this also includes an instruction queue (which replaces instantiation), and supercombinators are compiled to a sequence of instructions.

This stack-based machine is desirable for several efficiency reasons: it requires a simpler (smaller) runtime; it does not require the re-traversal of a supercombinator's body expression on each expression; and the runtime does not require an expression-level representation of the language.

\subsection{List of opcodes}
\label{sec:gm-opcodes}

The list of opcodes of the abstract stack machine that the G-Machine compiles to is given below. For the sake of this document, the dynamic semantics of each opcode is only provided informally\footnote{The syntax of this assembly-like language is trivial and need not be stated.}. A precise definition of most of the opcodes are given in the tutorial\footnote{Most of the time, the state transition(s) of an opcode are provided, and the implementation of the opcode in Haskell is left as an exercise.}.

\begin{description}
\item[\texttt{Pushglobal} $f$] Push the address of the global (supercombinator) $f$ onto the stack\footnote{This is overloaded in Mark 6 for a technicality regarding unsaturated data constructors. This is Exercise 3.38.}.
\item[\texttt{Pushint} $n$] Push the address of an integer node representing the integer $n$ onto the stack. If such an integer node representing the integer $n$ already exists, this may use that existing address; otherwise, this will allocate a new integer node $n$.
\item[\texttt{Push} $n$] Push the $n$-th address of the stack onto the stack.
\item[\texttt{Update} $n$] Set the node pointed to by the $n$-th address of the stack to an indirection node pointing to the top element of the stack, then pop one element from the stack.
\item[\texttt{Pop} $n$] Pop $n$ elements from the stack.
\item[\texttt{Alloc} $n$] Push $n$ invalid addresses onto the stack, or decrease the stack pointer by $n$ \footnote{This is used for \texttt{letrec} expressions. These addresses initially point to an invalid node, and will be updated by the evaluation of the definiens.}.
\item[\texttt{Slide} $n$] ``Slide'' the top element of the stack up $n$ slots. In other words, the $(n+1)$-th element of the stack will be replaced with the top of the stack, and then $n$ elements will be popped.
\item[\texttt{Unwind}] Same as in the TI implementation \Cref{sec:ti-unwind}.
\item[\texttt{Mkap}] Pop two elements from the stack, allocate a new application node (with the first popped element in function position, and the second popped element in argument position) and push the application node onto the stack.
\item[\texttt{Eval}] Strictly evaluate the element on the top of the stack to WHNF on a new stack (frame)\footnote{This pushes a new stack on the dump and evaluates the node on the new stack. This is more or less equivalent to a function call in the conventional procedural ABIs.}.
\item[\texttt{Add}, \texttt{Sub}, \texttt{Mul}, \texttt{Div}, \texttt{Neg}] Arithmetic binary and unary operators. Assumes the two elements on the top of the stack are evaluated to integers (otherwise will crash the program). Pops the top two elements and leaves a number node on the top of the stack representing the arithmetic result.
\item[\texttt{Eq}, \texttt{Ne}, \texttt{Lt}, \texttt{Le}, \texttt{Gt}, \texttt{Ge}] Relational binary operators. Assumes the two elements on the top of the stack are evaluated to booleans in the standard representation (otherwise will crash the program). Pops the top two elements and leaves a node on the top of the stack representing the boolean result in the standard representation.
\item[\texttt{Pack} $t$ $n$] Pops $n$ addresses from the stack. Allocate and push a structured data node representing structured data with tag $t$ and the $n$ popped arguments.
\item[\texttt{Casejump} $rules$] The set $rules$ is of the form $\{t_j\to [i_1,i_2,\dots]\}$: a mapping of tags $t_j$ to code sequences $[i_1,i_2,\dots]$. Assumes the top of the stack is the scrutinee of a \texttt{case} expression, and thus a data node with tag $t$. Appends the instruction list of the appropriate rule onto the current instruction queue. Throws an error if the scrutinee is not a structured data node or if there is no match.
\item[\texttt{Split} $n$] Assumes the top of the stack is a structured data node. Pops it from the stack, and then pushes its $n$ arguments onto the stack.
\item[\texttt{Print}] Output the top element on the stack. Assumes that it is a data node (integer or structured data node). Recursively generates additional \texttt{Print} and \texttt{Eval} opcodes for structured data.

\end{description}

\subsection{Compilation schemes}
\label{sec:compilation-schemes}

\todo{list each compilation scheme, describe it, show its behavior on expression types}

\subsubsection{Non-strict vs. strict compilation context}
\label{sec:strict-context}

\todo{fit this in nicely with the previous section???}

\subsection{Evaluator}
\label{sec:evaluator}

The evaluator implements the abstract stack machine. Each of the opcodes described in \Cref{sec:gm-opcodes} is implemented as a separate function in the G-Machines's \texttt{Evaluator} module.

\subsubsection{Transpilation to x86-64 assembly code}
\label{sec:gm-transpile-x86}

To illustrate the simplicity of the G-Machine's runtime, the stack machine of the Mark 1 of the G-Machine was implemented in NASM x86-64 assembly code. Each stack machine opcode was implemented using an assembly macro. Supercombinator node definitions are also implemented with a macro. This can be found on GitHub at \href{https://github.com/jlam55555/flc-transpiler}{jlam55555/flc-transpiler}.

I did not have time to implement later Marks of the G-Machine in assembly code, and I believe that it is a reasonable project for future work. However, the increased complexity of later Marks will likely be convenienced by small helper functions written in C.

\subsection{Sample compilations and evaluations}
\label{sec:compiler-examples}

\todo{this section}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
